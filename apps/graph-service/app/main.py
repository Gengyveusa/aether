from fastapi import Depends, FastAPI, HTTPException
from typing import Any, Dict, Optional
from jsonschema import Draft7Validator
from .schema_loader import load_schema
import uuid
from datetime import datetime, timezone
from sqlalchemy.exc import IntegrityError
from .backends.factory import get_graph_backend_dep
from .backends.base import GraphBackend
from . import crud
from .schemas import SourceDocumentCreate
from . import graph_api

app = FastAPI(title="Aether Graph Service", version="0.0.0")

# Load schemas (generated by packages/shared-types)
ENTITY_SCHEMA = load_schema("Entity")
RELATIONSHIP_SCHEMA = load_schema("Relationship")
CANONICAL_CONTENT_SCHEMA = load_schema("CanonicalContent")
BRAND_POLICY_SCHEMA = load_schema("BrandPolicy")

entity_validator = Draft7Validator(ENTITY_SCHEMA)
relationship_validator = Draft7Validator(RELATIONSHIP_SCHEMA)
canonical_content_validator = Draft7Validator(CANONICAL_CONTENT_SCHEMA)
brand_policy_validator = Draft7Validator(BRAND_POLICY_SCHEMA)


def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def validate_or_400(validator: Draft7Validator, payload: Dict[str, Any]):
    errors = sorted(validator.iter_errors(payload), key=lambda e: e.path)
    if errors:
        raise HTTPException(status_code=400, detail=[e.message for e in errors])


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/entities")
async def create_entity(payload: Dict[str, Any], backend: GraphBackend = Depends(get_graph_backend_dep)):
    # Assign server-side fields if omitted.
    try:
        entity_id = payload.get("id") or str(uuid.uuid4())
        uuid.UUID(entity_id)  # ensure UUID
    except ValueError:
        raise HTTPException(status_code=400, detail="id must be a UUID string")

    payload["id"] = entity_id

    ts = now_iso()
    payload["createdAt"] = payload.get("createdAt") or ts
    payload["updatedAt"] = ts

    validate_or_400(entity_validator, payload)

    try:
        created = await backend.create_entity(payload)
    except IntegrityError:
        # slug unique constraint, etc.
        raise HTTPException(status_code=409, detail="Entity already exists (slug conflict)")
    return created


@app.get("/entities/{id}")
async def get_entity(id: str, backend: GraphBackend = Depends(get_graph_backend_dep)):
    entity = await backend.get_entity(id)
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")
    return entity


@app.get("/entities")
async def list_entities(
    type: Optional[str] = None,
    brandId: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    backend: GraphBackend = Depends(get_graph_backend_dep),
):
    if brandId:
        try:
            uuid.UUID(brandId)
        except ValueError:
            raise HTTPException(status_code=400, detail="brandId must be a UUID string")
    if limit < 1 or limit > 200:
        raise HTTPException(status_code=400, detail="limit must be between 1 and 200")
    if offset < 0:
        raise HTTPException(status_code=400, detail="offset must be >= 0")

    items = await backend.list_entities(entity_type=type, brand_id=brandId, limit=limit, offset=offset)
    return {"entities": items}


@app.put("/canonical-content/{entityId}")
async def put_canonical_content(entityId: str, payload: Dict[str, Any], backend: GraphBackend = Depends(get_graph_backend_dep)):
    # Ensure entityId consistency
    payload["entityId"] = payload.get("entityId") or entityId
    if payload["entityId"] != entityId:
        raise HTTPException(status_code=400, detail="entityId in body must match path entityId")

    validate_or_400(canonical_content_validator, payload)
    # Ensure referenced entity exists
    entity = await backend.get_entity(entityId)
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")

    stored = await backend.upsert_canonical_content(entityId, payload)
    return stored


@app.get("/canonical-content/{entityId}")
async def get_canonical_content(entityId: str, backend: GraphBackend = Depends(get_graph_backend_dep)):
    content = await backend.get_canonical_content(entityId)
    if not content:
        raise HTTPException(status_code=404, detail="CanonicalContent not found")
    return content


@app.post("/source-documents")
async def create_source_document(req: SourceDocumentCreate, backend: GraphBackend = Depends(get_graph_backend_dep)):
    # Validate brand existence and type
    entity = await backend.get_entity(req.brandId)
    if not entity:
        raise HTTPException(status_code=404, detail="Brand not found")
    if entity.get("type") != "brand":
        raise HTTPException(status_code=400, detail="brandId must reference an entity of type 'brand'")

    try:
        doc = await backend.create_source_document(req.model_dump())
    except IntegrityError:
        # brand+url unique
        raise HTTPException(status_code=409, detail="Source document already exists for this brand+url")
    return doc


@app.get("/source-documents")
async def list_source_documents(brandId: str, backend: GraphBackend = Depends(get_graph_backend_dep)):
    try:
        uuid.UUID(brandId)
    except ValueError:
        raise HTTPException(status_code=400, detail="brandId must be a UUID string")
    docs = await backend.list_source_documents(brandId)
    return {"sourceDocuments": docs}


@app.post("/relationships")
async def create_relationship(payload: Dict[str, Any], backend: GraphBackend = Depends(get_graph_backend_dep)):
    # Assign server-side fields if omitted.
    try:
        rel_id = payload.get("id") or str(uuid.uuid4())
        uuid.UUID(rel_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="id must be a UUID string")
    payload["id"] = rel_id

    ts = now_iso()
    payload["createdAt"] = payload.get("createdAt") or ts
    payload["updatedAt"] = ts
    payload["proofIds"] = payload.get("proofIds") or []

    validate_or_400(relationship_validator, payload)

    # Ensure referenced entities exist
    if not await backend.get_entity(payload["fromEntityId"]):
        raise HTTPException(status_code=404, detail="fromEntityId not found")
    if not await backend.get_entity(payload["toEntityId"]):
        raise HTTPException(status_code=404, detail="toEntityId not found")

    try:
        created = await backend.create_relationship(payload)
    except IntegrityError:
        raise HTTPException(status_code=409, detail="Relationship already exists")
    return created


@app.get("/relationships")
async def list_relationships(
    fromEntityId: Optional[str] = None,
    toEntityId: Optional[str] = None,
    type: Optional[str] = None,
    backend: GraphBackend = Depends(get_graph_backend_dep),
):
    for v, name in ((fromEntityId, "fromEntityId"), (toEntityId, "toEntityId")):
        if v:
            try:
                uuid.UUID(v)
            except ValueError:
                raise HTTPException(status_code=400, detail=f"{name} must be a UUID string")

    rels = await backend.list_relationships(
        from_entity_id=fromEntityId,
        to_entity_id=toEntityId,
        rel_type=type,
    )
    return {"relationships": rels}


@app.get("/graph/entities/{id}/neighbors")
async def get_entity_neighbors(
    id: str,
    relationshipTypes: Optional[str] = None,
    backend: GraphBackend = Depends(get_graph_backend_dep),
):
    entity = await backend.get_entity(id)
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")

    rel_types: Optional[list[str]] = None
    if relationshipTypes:
        rel_types = [t for t in (s.strip() for s in relationshipTypes.split(",")) if t]

    neighbors = await backend.get_neighbors(id, relationship_types=rel_types)
    return {"entity": entity, "neighbors": neighbors}


@app.get("/indexing/entity-bundle/{entityId}")
async def get_indexing_entity_bundle(entityId: str, backend: GraphBackend = Depends(get_graph_backend_dep)):
    entity = await backend.get_entity(entityId)
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")

    canonical = await backend.get_canonical_content(entityId)
    source_docs: list[dict[str, Any]] = []

    # Source documents are currently linked to Brand entities.
    if entity.get("type") == "brand":
        source_docs = await backend.list_source_documents_with_content(entityId)

    return {"entity": entity, "canonicalContent": canonical, "sourceDocuments": source_docs}


def default_brand_policy() -> Dict[str, Any]:
    # Keep defaults aligned with shared-types BrandPolicy defaults.
    return {
        "allowedClaims": {"canUseSuperlatives": False, "allowedSuperlatives": [], "allowedComparisons": []},
        "forbiddenPhrases": [],
        "regulatedTopics": [],
    }


@app.get("/brand-policies/{brandId}")
async def get_brand_policy(
    brandId: str,
    includeDefault: bool = True,
    backend: GraphBackend = Depends(get_graph_backend_dep),
):
    entity = await backend.get_entity(brandId)
    if not entity:
        raise HTTPException(status_code=404, detail="Brand not found")
    if entity.get("type") != "brand":
        raise HTTPException(status_code=400, detail="brandId must reference an entity of type 'brand'")

    policy = await backend.get_brand_policy(brandId)
    if policy:
        return policy
    if includeDefault:
        return default_brand_policy()
    raise HTTPException(status_code=404, detail="BrandPolicy not found")


@app.put("/brand-policies/{brandId}")
async def put_brand_policy(brandId: str, payload: Dict[str, Any], backend: GraphBackend = Depends(get_graph_backend_dep)):
    entity = await backend.get_entity(brandId)
    if not entity:
        raise HTTPException(status_code=404, detail="Brand not found")
    if entity.get("type") != "brand":
        raise HTTPException(status_code=400, detail="brandId must reference an entity of type 'brand'")

    validate_or_400(brand_policy_validator, payload)
    stored = await backend.upsert_brand_policy(brandId, payload)
    return stored
